#! /usr/bin/env python 
import sys
import os
from itertools import cycle

# Qt4 bindings for core Qt functionalities (non-GUI)
from PyQt4 import QtCore

# Python Qt4 bindings for GUI objects
from PyQt4 import QtGui

from PyQt4.QtCore import Qt

from numpy import *

# import the MainWindow widget from the converted .ui files
from mainwindow import Ui_MainWindow
from modeldata import HDF5Data, RealtimeData, DirectoryData, OldDirectoryData

COLOR_SERIES = ["#5555ff", "#ff5555", "#909090",
                "#ff55ff", "#008800", "#8d0ade",
                "#33bbcc", "#000000", "#444400",
                "#7777ff", "#77ff77"]
LINE_WIDTH = 1.7

# We do not plot densities or rates below these thresholds
DENS_THRESHOLD = 1e-10
RATE_THRESHOLD = 1e-20

class DesignerMainWindow(QtGui.QMainWindow, Ui_MainWindow):
    """Customization for Qt Designer created window"""
    def __init__(self, parent = None):
        # initialization of the superclass
        super(DesignerMainWindow, self).__init__(parent)
        # setup the GUI --> function generated by pyuic4
        self.setupUi(self)

        # In some lists we can select more than one item
        self.speciesList.setSelectionMode(
            QtGui.QAbstractItemView.ExtendedSelection)
        self.reactList.setSelectionMode(
            QtGui.QAbstractItemView.ExtendedSelection)
        
        self.plot_widgets = [self.condWidget,
                             self.densWidget,
                             self.reactWidget,
                             self.sourceWidget]
        
        self.update_timer = QtCore.QTimer()

        # connect the signals with the slots
        QtCore.QObject.connect(self.condButton, 
                               QtCore.SIGNAL("clicked()"),
                               self.update_cond_graph)

        QtCore.QObject.connect(self.plotButton, 
                               QtCore.SIGNAL("clicked()"),
                               self.update_spec_graph)

        QtCore.QObject.connect(self.sourceButton, 
                               QtCore.SIGNAL("clicked()"),
                               self.update_source_graph)

        QtCore.QObject.connect(self.reactButton, 
                               QtCore.SIGNAL("clicked()"),
                               self.update_react_graph)

        QtCore.QObject.connect(self.actionOpen, 
                               QtCore.SIGNAL('triggered()'),
                               self.select_file)

        QtCore.QObject.connect(self.actionStart_a_simulation, 
                               QtCore.SIGNAL('triggered()'),
                               self.start_a_simulation)

        QtCore.QObject.connect(self.actionImport_from_directory, 
                               QtCore.SIGNAL('triggered()'),
                               self.import_from_directory)

        QtCore.QObject.connect(self.actionUpdate, 
                               QtCore.SIGNAL('triggered()'),
                               self.data_update)

        QtCore.QObject.connect(self.actionExport_data, 
                               QtCore.SIGNAL('triggered()'),
                               self.export_data)

        QtCore.QObject.connect(self.actionSave, 
                               QtCore.SIGNAL('triggered()'),
                               self.save_to_file)

        QtCore.QObject.connect(self.actionLog_scale_in_time, 
                               QtCore.SIGNAL('triggered()'),
                               self.action_set_logtime)

        QtCore.QObject.connect(self.actionQuit, 
                               QtCore.SIGNAL('triggered()'), 
                               QtGui.qApp, QtCore.SLOT("quit()"))
    
        QtCore.QObject.connect(self.update_timer,
                               QtCore.SIGNAL("timeout()"),
                               self.data_update)

    @property
    def xscale(self):
        if self.actionLog_scale_in_time.isChecked():
            return 'log'
        else:
            return 'linear'
        
    def update_cond_graph(self):
        """Updates the graph with densities"""

        ylabels = {
            'gas_temperature':
            "Gas temperature [K]",
            'reduced_frequency':
            "Reduced frequency cm$^\mathdefault{3}$s$^\mathdefault{-1}$",
            'reduced_field':
            "Reduced field E/N [Td]",
            'elec_temperature':
            "Electron temperature [K]",
            'elec_drift_velocity':
            "Electron drift velocity [cm/s]",
            'elec_diff_coeff':
            "Electron diffusion coeff. [cm$^\mathdefault{2}$s$^\mathdefault{-1}$]",
            'elec_frequency_n':
            "Electron reduced colission freq. [cm$^\mathdefault{3}$s$^\mathdefault{-1}$]",
            'elec_power_n':
            "Electron reduced power [eV cm$^\mathdefault{3}$s$^\mathdefault{-1}$]",
            'elec_power_elastic_n':
            "Electron reduced elastic power [eV cm$^\mathdefault{3}$s$^\mathdefault{-1}$]",
            'elec_power_inelastic_n':
            "Electron reduced inelastic power [eV cm$^\mathdefault{3}$s$^\mathdefault{-1}$]"}

        try:
            condition = str(self.condList.currentItem().text())
        except AttributeError:
            return

        # clear the Axes
        if not self.condWidget.axes:
            self.condWidget.init_axes()
        else:
            self.condWidget.clear()

        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(Qt.WaitCursor))
        
        y = array(self.data.condition(condition))
        flt = y > 0
        self.condWidget.axes[0].plot(self.data.t[flt], y[flt], lw=LINE_WIDTH,
                                     label=ylabels.get(condition, condition),
                                     zorder=10)

        self.condWidget.set_scales(yscale='linear', xscale=self.xscale)
        self.condWidget.axes[0].set_xlabel("t [s]")
        self.condWidget.axes[0].set_ylabel(ylabels.get(condition, condition))

        # force an image redraw
        self.condWidget.draw()
        
        QtGui.QApplication.restoreOverrideCursor()


    def update_spec_graph(self):
        """Updates the graph with densities"""
        # clear the Axes
        if not self.speciesList.selectedItems():
            return

        if not self.densWidget.axes:
            self.densWidget.init_axes()
        else:
            self.densWidget.clear()

        
        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(Qt.WaitCursor))
        self.data.flush()
        citer = cycle(COLOR_SERIES)
        
        for item in self.speciesList.selectedItems():
            name = unicode(item.text())
            dens = self.data.density(name)
            flt = dens > DENS_THRESHOLD
            self.densWidget.axes[0].plot(self.data.t[flt], dens[flt],
                                         lw=LINE_WIDTH,
                                         c=citer.next(), label=name,
                                         zorder=10)

        self.densWidget.set_scales(yscale='log', xscale=self.xscale)
        self.densWidget.axes[0].set_xlabel("t [s]")
        self.densWidget.axes[0].set_ylabel("Density [cm$^\mathdefault{-3}$]")
        self.densWidget.axes[0].legend(loc=(1.05, 0.0), prop=dict(size=11))

        # force an image redraw
        self.densWidget.draw()

        QtGui.QApplication.restoreOverrideCursor()


    def update_source_graph(self):
        """Updates the graph with sources rates"""
        try:
            species = unicode(self.speciesSourceList.currentItem().text())
        except AttributeError:
            return
        
        # clear the Axes
        if not self.sourceWidget.axes:
            self.sourceWidget.init_axes()
        else:
            self.sourceWidget.clear()

        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(Qt.WaitCursor))
        
        dreactions = self.data.sources(species)
        reactions = dreactions.keys()
        
        r = zeros((len(reactions), len(self.data.t)))
        for i, react in enumerate(reactions):
            r[i, :] = dreactions[react]
            
        # Find the reactions that are at some point at least a delta of the total
        delta = 0.1

        spos = nanmax(where(r > 0, r, 0), axis=0)
        fpos = r / spos

        # This is b.c. numpy does not provide a nanargsort
        fpos = where(isfinite(fpos), fpos, 0)
        
        sneg = nanmin(where(r < 0, r, 0), axis=0)
        fneg = r / sneg
        
        # This is b.c. numpy does not provide a nanargsort
        fneg = where(isfinite(fneg), fneg, 0)

        icreation = select_rates(fpos, delta)
        idestruct = select_rates(fneg, delta)

        citer = cycle(COLOR_SERIES)
        for i in icreation:
            name = reactions[i]
            flt = abs(r[i, :]) > RATE_THRESHOLD
            self.sourceWidget.creationAx.plot(self.data.t[flt],
                                              abs(r[i, flt]),
                                              c=citer.next(),
                                              lw=LINE_WIDTH, label=name,
                                              zorder=10)

        citer = cycle(COLOR_SERIES)
        for i in idestruct:
            name = reactions[i]
            flt = abs(r[i, :]) > RATE_THRESHOLD
            self.sourceWidget.removalAx.plot(self.data.t[flt],
                                             abs(r[i, flt]),
                                             c=citer.next(),
                                             lw=LINE_WIDTH, label=name,
                                             zorder=10)

        self.sourceWidget.creationAx.set_ylabel(
            "Production [cm$^\mathdefault{-3}$s$^\mathdefault{-1}$]")
        self.sourceWidget.creationAx.legend(loc=(1.05, 0.0),
                                            prop=dict(size=9))


        self.sourceWidget.removalAx.set_ylabel(
            "Losses [cm$^\mathdefault{-3}$s$^\mathdefault{-1}$]")
        self.sourceWidget.removalAx.set_xlabel("t [s]")

        self.sourceWidget.removalAx.legend(loc=(1.05, 0.0),
                                           prop=dict(size=9))

        
        self.sourceWidget.set_scales(yscale='log', xscale=self.xscale)

        # force an image redraw
        self.sourceWidget.draw()

        QtGui.QApplication.restoreOverrideCursor()


    def update_react_graph(self):
        """Updates the graph with reaction rates"""
        if not self.reactList.selectedItems():
            return
        
        # clear the Axes
        if not self.reactWidget.axes:
            self.reactWidget.init_axes()
        else:
            self.reactWidget.clear()

        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(Qt.WaitCursor))

        citer = cycle(COLOR_SERIES)
        for item in self.reactList.selectedItems():
            name = str(item.text())
            rate = array(self.data.rate(name))
            
            flt = rate > RATE_THRESHOLD
            self.reactWidget.axes[0].plot(self.data.t[flt], rate[flt],
                                          c=citer.next(),
                                          lw=LINE_WIDTH, label=name,
                                          zorder=10)

        self.reactWidget.set_scales(yscale='log', xscale=self.xscale)
            
        self.reactWidget.axes[0].set_xlabel("t [s]")
        self.reactWidget.axes[0].set_ylabel(
            "Rate [cm$^\mathdefault{-3}$s$^\mathdefault{-1}$]")
        self.reactWidget.axes[0].legend(loc=(1.025, 0.0),
                                        prop=dict(size=8))

        # force an image redraw
        self.reactWidget.draw()

        QtGui.QApplication.restoreOverrideCursor()



    def select_file(self):
        """opens a file select dialog"""
        # open the dialog and get the selected file
        file = QtGui.QFileDialog.getOpenFileName(self, "Open data file",
                                                 ".",
                                                 "HDF5 files (*.h5 *.hdf5);;"
                                                 "All files (*)")
        # if a file is selected
        if file:
            try:
                self.load_h5file(unicode(file))
                self.setWindowTitle("%s - QtPlaskin" % file)

                self.update_lists()
                self.clear()

            except IOError as e:
                QtGui.QErrorMessage(self).showMessage(
                    "Failed to open file.  Incorrect format? <%s>" % e)
                

    def start_a_simulation(self):
        self.data = RealtimeData('fpr_1', 'init_species.dat',
                                 'field_constant.tsv',
                                 max_dt=10e-3)
        self.update_lists()


    def import_from_directory(self):
        
        fname = QtGui.QFileDialog.getExistingDirectory(
            self, "Import data from directory",
            ".", QtGui.QFileDialog.ShowDirsOnly)

        if fname:
            try:
                try:
                    self.data = DirectoryData(unicode(fname))
                except IOError as e:
                    em = QtGui.QErrorMessage(self)
                    em.setModal(True)
                    em.showMessage(
                        ("Failed to open directory (%s).\n" % str(e))
                        + "I will try now to import files in deprecated format.")
                    # If we do not call exec_ here, two dialogs may appear at
                    # the same time, confusing the user.
                    em.exec_()
                    self.data = OldDirectoryData(unicode(fname))

                self.setWindowTitle("%s - QtPlaskin" % fname)
                self.update_lists()
                self.clear()
            except IOError as e:
                em = QtGui.QErrorMessage(self)
                em.setModal(True)
                em.exec_()
                em.showMessage(
                    "Failed to open directory (%s).\n" % str(e))
                
        # Update every 30 s
        # self.update_timer.start(10000)


    def data_update(self):
        self.data.update()
        
        self.update_cond_graph()
        self.update_spec_graph()
        self.update_source_graph()
        self.update_react_graph()
        
    
    def save_to_file(self):
        """opens a file select dialog"""
        # open the dialog and get the selected file
        fname = QtGui.QFileDialog.getSaveFileName(self, "Save to file",
                                                  ".",
                                                  "HDF5 files (*.h5 *.hdf5);;"
                                                  "All files (*)")

        # if a file is selected
        if fname:
            self.data.save(unicode(fname))
    

    def export_data(self):
        """opens a file select dialog"""
        # open the dialog and get the selected file
        fname = QtGui.QFileDialog.getSaveFileName(self, "Export data to file",
                                                  ".",
                                                  "TSV files (*.tsv);;"
                                                  "TXT files (*.txt);;"
                                                  "DAT files (*.dat);;"
                                                  "All files (*)")

        # if a file is selected
        if fname:
            fname = unicode(fname)
            self.plot_widgets[self.tabWidget.currentIndex()].savedata(fname)
        
            
    def action_set_logtime(self):
        for w in self.plot_widgets:
            w.set_scales(xscale=self.xscale, redraw=True)
        

    def load_h5file(self, file):
        self.data = HDF5Data(file)
        self.update_lists()
        self.clear()
        

    def update_lists(self):
        self.species = sorted(self.data.species)
        self.reactions = sorted(self.data.reactions)
        self.conditions = sorted(self.data.conditions)

        self.speciesList.clear()
        self.speciesList.addItems(self.species)

        self.speciesSourceList.clear()
        self.speciesSourceList.addItems(self.species)

        self.reactList.clear()
        self.reactList.addItems(self.reactions)

        self.condList.clear()
        self.condList.addItems(self.conditions)
        
        
    def clear(self):
        for w in self.plot_widgets:
            w.clear()
        
        
    def parse_file(self, filename):
        pass


def select_rates(f, delta, max_rates=4, min_rates=0):
    fmax = nanmax(f, axis=1)
    
    asort = argsort(-fmax)
    n = len(asort)

    # We always select at least the highest min_rates.
    highest = asort[:min_rates]

    # if n < max_rates:
    #    return highest

    # From the rest, we select those larger than delta, but not more
    # than max_rates
    p = asort[min_rates:max_rates]
    rest = p[fmax[p] > delta]
    
    if n == max_rates:
        return r_[highest, rest]

    # We should never leave aside rates that at some point are very
    # important, even if they fall outside max_rates
    p = asort[max_rates:]
    rest2 = p[fmax[p] > (1 - delta)]
    return r_[highest, rest, rest2]
    

    


# create the GUI application
app = QtGui.QApplication(sys.argv)

# instantiate the main window
dmw = DesignerMainWindow()

# show it
dmw.show()
dmw.raise_()

# start the Qt main loop execution, exiting from this script
# with the same return code of Qt application
sys.exit(app.exec_())
